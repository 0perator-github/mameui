// For licensing and usage information, read docs/winui_license.txt
//****************************************************************************

/***************************************************************************

    mkhelp.cpp

    Simple resource HIDC to Help entry tool.

    MSH - 20070815

***************************************************************************/

// standard C++ headers
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>

// standard windows headers

// MAME headers
#include "osdcore.h"

// MAMEUI headers
#include "mui_cstr.h"

#include "mui_util.h"

static int compare( const void *arg1, const void *arg2 );
static void extract_help_ids(const char *buffer, FILE *fp);

/*-------------------------------------------------
    main - primary entry point
-------------------------------------------------*/

int main(int argc, char *argv[])
{
	const char *resourcefile, *varname, *type;
	std::ofstream ofs_resource;
	std::unique_ptr<char[]> buffer;
	int bytes;

	varname = "dwHelpIDs";
	type = "DWORD";

	/* needs at least three arguments */
	if (argc < 1)
	{
		std::cerr << "Usage:\n  mkhelp <resource.rc>\n\n"
			<< "The default <type> is DWORD, with an assumed nullptr terminator pair" << std::endl;
		return 0;
	}

	/* extract arguments */
	resourcefile = argv[1];

	/* open source file */

	ofs_resource.open(resourcefile, std::ofstream::ate);
	if (!ofs_resource.is_open())
	{
		std::cerr << "Unable to open resource file '"<< resourcefile<< "'" << std::endl;
		return 1;
	}

	/* determine file size */
	bytes = ofs_resource.tellg();
	ofs_resource.seekg(0, ofs_resource.beg);

	/* allocate memory */
	buffer = std::make_unique<char[]>(bytes + 1);
	if (!buffer)
	{
		ofs_resource.close();
		std::cerr << "Out of memory allocating %d byte buffer\n", bytes);
		return 1;
	}

	/* read the source file */
	ofs_resource.read(buffer, 1, bytes);
	buffer[bytes] = 0;
	ofs_resource.close();

	/* open dest file */
	ofs_resource << "/*\n * Help ID array - Generated by mkhelp\n */\n\n"
		<< "#include <windows.h>\n#include \"resource.h\"\n#include \"resource.hm\"\n\n"
		<< "extern const /*\n * Help ID array - Generated by mkhelp\n */\n\n"
		<< "#include <windows.h>\n#include \"resource.h\"\n#include \"resource.hm\"\n\n"
		/* write the initial header */
		<< "extern const " << type << " " << varname << "[] = \n{\n" << std::fflush;

	extract_help_ids(buffer, dst);

	ofs_resource << "\n};" << std::endl;

	/* close the files */
	ofs_resource.close();

	return 0;
}

static int compare( const void *arg1, const void *arg2 )
{
	/* Compare all of both strings: */
	return mui_stricmp( * ( char** ) arg1, * ( char** ) arg2 );
}

#pragma GCC diagnostic ignored "-Wsizeof-pointer-memaccess"
static void extract_help_ids(const char* buffer, std::ofstream file_stream)
{
	const char* ptr = buffer;
	char** help_ids = new char* [500]('\0');
	int num_help_id = 0;
	int i;

	while (*ptr) {
		if (strncmp("HIDC_", ptr, 5) == 0) {
			char id_name[128], * end, * id;

			end = id_name;
			std::fill(std::begin(id_name), std::end(id_name), '\0');
			while (*ptr && *ptr != '\x0d' && *ptr != '\x0a') {
				*end++ = *ptr++;
			}
			id = new char[strlen(id_name)]('\0');
			(void)mui_strcpy(id, &id_name[1], strlen(&id_name[1]));
			help_ids[num_help_id] = id;
			num_help_id++;
		}
		else {
			ptr++;
		}
	}

	/* Sort using Quicksort algorithm: */
	qsort((void*)help_ids, (size_t)num_help_id, sizeof(char*), compare);

	// Now print them out.
	ptr = help_ids[0];
	for (i = 0; i < num_help_id; i++) {
		if (i > 0) {
			if (mui_strcmp(ptr, help_ids[i]) == 0) {
				continue;
			}
		}
		file_stream << "\t" << std::setw(30) << help_ids[i] << std::ws << "H" << help_ids[i] << std::endl;
		ptr = help_ids[i];
	}
	file_stream << "\t" << setw(30) << 0 ", " << 0;

	// free our allocations.
	delete[] help_ids[i];
}
#pragma GCC diagnostic error "-Wsizeof-pointer-memaccess"

